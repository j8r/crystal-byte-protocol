require "./client"
require "./server"

# Convert Crystal protocol messages to JavaScript, using the  https://github.com/j8r/js-byte-format library.
module CrystalByteProtocol::CrystalToJS
  def self.convert_to_file(
    file : Path | String,
    module_to_convert : M.class,
    file_path = __FILE__
  ) forall M
    File.open file, "w" do |io|
      io.puts "// DO NOT EDIT: file auto-generated by #{File.basename file_path}."
      source_type = module_to_convert.is_a?(Client) ? SourceType::Client : SourceType::Server
      CrystalToJS.convert_all io, M, source_type: source_type
      CrystalToJS.convert_to_dict io, M, source_type, types: true
      io.puts
    end
  end

  alias Types = String | Bool | Int8 | UInt8 | Int16 | UInt16 | Int32 | UInt32 | Float32 | Float64

  enum SourceType
    Client
    Server
  end

  # Yiels each object name of `T` with its JS conversion. If the object contains others, they are also added.
  def self.convert_all(io : IO, type : T.class, source_type : SourceType) forall T
    {% for module_name in T.constants %}
      {% module_const = T.constant(module_name) %}
      io << "export "
      convert io, {{module_const}}, source_type: source_type

      {% for obj_name in module_const.constants %}
        {% obj_const = module_const.constant(obj_name) %}
        io << "\n\n" 
        # Generate enums when iterating on ivars
        {% if !(obj_const <= Enum) %}
          convert io, {{obj_const}}, source_type: source_type
        {% end %}
      {% end %}
      io << '\n'
    {% end %}
  end

  # Converts an enum to JS.
  # If no name is defined, it is supposed to be a string enum of a message.
  def self.convert_enum(io : IO, type : Enum.class, source_type : SourceType, types : Bool = false) : Nil
    io << " = Object.freeze({"
    type.each do |member, value|
      io << "\n  "
      case source_type
      in .client?
        # Client only need strings, to convert to number to send to the server
        io << member << ": " << value
      in .server?
        # Messages received from the server are numbers, to convert to string
        io << value << ": "
        io << '"' if !types
        io << member
        io << '"' if !types
      end
      io << ','
    end
    io << "\n})"
  end

  def self.convert_to_dict(io : IO, type : T.class, source_type : SourceType, types : Bool = false) : Nil forall T
    value = {{ T.constants.size <= UInt8::MAX ? 0_u8 : 0_u16 }}
    if source_type.server?
      io << "\nconst Messages = Object.freeze({"
    end
    {{T.constants.map &.stringify}}.each do |member|
      io << '\n'
      case source_type
      in .client?
        # Client only need strings, to convert to number to send to the server
        io << member << ".protocolNumber = " << value
      in .server?
        # Messages received from the server are numbers, to convert to string
        io << "  " << value << ": "
        io << '"' if !types
        io << member
        io << '"' if !types
        io << ','
      end
      value += 1
    end

    type = value.class.to_s.downcase.camelcase
    io << "\n})" if source_type.server?
    io << "\n\nexport function "
    case source_type
    in .client?
      io << <<-E
      serialize(byteEncoder, object) {
        byteEncoder.write#{type}(object.constructor.protocolNumber)
        object.encode(byteEncoder)
        return byteEncoder.toBytes()
      }
      E
    in .server?
      io << <<-E
      deserialize(byteDecoder) {
        return new Messages[byteDecoder.read#{type}()](byteDecoder)
      }
      E
    end
  end

  def self.type_last_name(type)
    type.name.rpartition("::").last
  end

  # Converts a type to JS.
  def self.convert(io : IO, type : T.class, source_type : SourceType) : Nil forall T
    type_name = type_last_name T
    instance_vars = {{ T.instance_vars.empty? ? "Array({String, Nil.class}).new".id : T.instance_vars.map { |ivar| {ivar.stringify, ivar.type} } }}
    io << "class " << type_name << " {\n"
    case source_type
    in .client?
      io << <<-E
        /** @param {ByteEncoder} encoder */
        encode(encoder) {
      E
    in .server?
      io << <<-E
        /** @param {ByteDecoder} decoder */
        constructor(decoder) {
      E
    end

    case source_type
    in .client?
      instance_vars.each do |name, ivar_type|
        io << "\n    encoder.write"
        if ivar_type.is_a? Enum.class
          io << typeof(ivar_type.values.first.value).name.downcase.camelcase
          io << '(' << type_name << '.' << type_last_name ivar_type
          io << "[this." << name.camelcase(lower: true) << "])"
        else
          io << ivar_type.name.downcase.camelcase << "(this." << name.camelcase(lower: true) << ')'
        end
      end
    in .server?
      instance_vars.each do |name, ivar_type|
        io << "\n    this." << name.camelcase(lower: true) << " = "
        if ivar_type.is_a? Enum.class
          io << type_name << '.' << type_last_name ivar_type
          io << "[decoder.read" << typeof(ivar_type.values.first.value).name.downcase.camelcase << "()]"
        else
          io << "decoder.read" << ivar_type.name.downcase.camelcase << "()"
        end
      end
    end
    io << (instance_vars.empty? ? "}\n}" : "\n  }\n}")

    instance_vars.each do |_, type|
      if type.is_a? Enum.class
        io << '\n' << type_name << '.' << type_last_name type
        convert_enum(
          io,
          type,
          source_type: source_type
        )
      end
    end
  end
end
